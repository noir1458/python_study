1. 연산자
1-1. 대입연산자
[예제]
#대입 연산자
a= (1 + 2) + 3
b= c * d / e


대입되는 값에 따라 변수의 타입이 결정된다. 한번 대입한 값은 다른 값을 대입하기 전까지 변하지 않고 기억된다.

파이썬은 변수를 선언하지 않고 바로 사용하며. 별도로 선언하지 값을 대입할때 변수를 생성하게 되어 있다. 대입연산자는 값을 저장한는것 뿐만 아니라 변수를 생성하고 초기화하는 역할을 겸한다.

대입에 의한 초기화가 선언을 겸하게 되므로. 변수를 사용하려면 초기값을 대입해야 한다.


1-2. 산술연산자
/는 소수점까지 정확하게 나눈다(실수 나누기)
//는 소수부는 버리고 정수부만 계산한다(정수나누기)
%는 나머지연산
**거듭제곱
나머지 사칙연산은 똑같다

나머지의 개념은 정수 수준의 나눗셈에서만 발생한다. //는 몫을 구하는 연산이며, %는 나머지를 구하는 연산이다.



1-3. 복합대입연산자
[예제]
a=3
a+=2
print(a)


a = a + 1 은 a+=1 과 같다.
+=연산자는 좌변의 값에 우변의 값을 더하라는 뜻이다. -=, *=, /= 등도 사용 가능하다.

C, Java 는 변수를 1 증가, 감소 시키는 ++,-- 연산자가 있는데. 파이썬에는 이 연산자가 없다.



2. 타입변환
[예제]
a = 'qwerty'
b = 'asdfg'
print(a+b)
#문자열 연결

print(a*3)
print('안녕'*4)
#문자열 반복


>결과
qwertyasdfg
qwertyqwertyqwerty
안녕안녕안녕안녕

연산자는 피연산자의 타입에 따라 동작이 달라진다. 산술연산자는 수치형에 사용하는것이 보통이지만, +와 *는 문자열에 대해서도 쓸수 있으며 수학적 연산과 다르게 동작한다.



[예제]
a = 'qwerty'

#print(a+123)
#print("11"+22)
#오류

print(a+str(123))
print("11"+str(22))
print(int("11")+22)


>결과
qwerty123
1122
33

+연산자는 피연산자의 타입을 구별해 연산할수 있지만, 타입이 다르면 연산할수 없게 된다.



2-1. 정수변환
[예제]
#print(1+int("%22"))
#오류 1
#print(1+int("22.1"))
#오류 2

print(int("1a",16))
#int 함수의 두번째 인수로 진법을 지정할 수 있다
#생략하면 10진법, 2~36진법까지 지정 가능
#문자열 내에 접두어 0x,0o,0b 가 붙어도 상관 없다


오류1 : 문자가 있어서 정수로 바꿀수 없다.
오류2 : 소수점이 있어서 정수가 아니다. 바꿀수 없다.



2-2. 실수변환
[예제]
print(1+float("11.2"))
print(1+float("314e-2"))


>결과
12.2
4.140000000000001

실수가 저장된 문자열을 실수로 변환할떄는 float함수를 사용한다. 문자열 안에는 부호와 숫자, 소수점 등으로 구성된 고정 소수점 실수나 부동 소수점 형식으로 저장되어 있어야 한다.


[예제]
print(1+int(11.1))
print(1+int(float("11.1")))


>결과
12
12

실수로 정수를 바꿀때에는 int 함수를 사용한다. 이때 소수점 이하는 사라진다.
문자열에 저장된 실수를 정수로 바꿀때는 일단 float 함수로 문자열을 실수로 바꾸고, 다시 int 함수를 사용해서 정수로 바꾼다.


[예제]
print(int(3.14))
print(round(3.14))
print(round(3.51))
print(round(3.14, 1))
print(round(1523.141592, -3))
# -3은 1000자리까지 유효한값으로 변환


>결과
3
3
4
3.1
2000.0

실수에 대해 int함수 호출시 소수점 이하를 무조건 잘라버려서 오차가 크게 발생하는데. round함수는 실수를 반올림한다. 값을 지정하지 않고 사용할경우 소수점 첫째 자리에서 반올림하여 정수를 리턴한다.



3. 우선순위와 결합순서
(검색해서 보기)

우선순위를 임의로 조정하려면 괄호를 사용해서 먼저 연산할 부분을 묶으면 된다.


[예제]
a = 1 + 2 + 3
a = b = c = 1


결합순서는 같은 연산자가 동시에 사용되었을 때 어떤 방향에서부터 연산할 것인지를 지정한다. 보통은 왼쪽 우선이라서 왼쪽부터 차례대로 연산한다.

대입연산자는 오른쪽 우선이다. 오른쪽부터 차례대로 대입해서 어러 변수에 한꺼번에 같은 값을 대입한다.




4. 조건문
여기부터는 코드가 여러줄이 되므로 스크립트로 실행해보는것이 좋다.

단순한 구조로는 복잡한 문제를 풀수 없다. 실행 흐름을 통제하는 문장을 제어문이라고 한다. 조건문은 진위여부에 따라 실행여부를 판단하는 제어문이다.


if 조건:
    명령

콜론을 쓰고 enter를 입력시 자동으로 한 블럭 띄어쓴 상태가 된다. 들여쓰기, 콜론, 명령문은 다음줄에 입력하는 이 형식은 반드시 지켜져야 한다.



[예제]
a=9
if a<10:
    print('10보다 작음')

if a<20:print('20보다 작음')


>결과
10보다 작음
20보다 작음

명령이 짧다면 한줄에 같이 적어도 좋다. 콜론 왼쪽에 조건, 오른쪽에 명령문이 오게된다.


[예제]
if a<10:
print('10보다 작음')


해석기는 들여쓰기한 줄을 윗줄의 연속으로 보기 떄문에 들여써야 이어지는 문장이 된다. 그렇지 않을 경우 에러가 발생한다


4-1. 비교연산자
[예제]
if 'a'<'A':
    print('대문자가 큼')
if 'a'>'A':
    print('소문자가 큼')


>결과
소문자가 큼

문자열끼리 비교한다면 사전순으로 비교하게 된다


타입 - 참 - 거짓
숫자 - 0이아닌 숫자 - 0
문자열 - 비어있지않은상태 - ""
리스트,튜플,딕셔너리 - 비어있지않은상태 - 빈상태
조건문에 비교연산식 대신 변수를 쓸 경우, 변수 자체가 논리식이 된다. 각 변수의 논리값은 이러하다.



[예제]
a=1
if a:
    print('참')


>결과
참

변수 자체를 논리식으로 사용해서, 0이 아니면 참이 된다.
이것은 'a != 0' 과 같다

C언어는 조건문에 대입식을 쓸수 있지만, 파이썬은 불가능하다. 대입과 비교를 동시에 할수 있지만, 이것 때문에 사고가 발생하게 된다.



4-2.논리연산자
and or not

[예제]
a=1
b=5
if a==1 and b==5:
    print('a가 1 b는 5')

if b>1 and b<10:
    print('b는 1보다 크고 10보다 작음')

if 1<b<10:
    print('파이썬은 이런 표기도 허용합니다')


>결과
a가 1 b는 5
b는 1보다 크고 10보다 작음
파이썬은 이런 표기도 허용합니다

파이썬은 세번째 조건문같은 직관적인 표기도 허용한다. (1<b<10)

and, or 연산자는 왼쪽의 비교식으로 전체가 결정될때, 오른쪽의 비교식은 판단하지 않음으로써 시간을 절약한다. 첫번째 비교식에서 a==1이 거짓이면, 전체가 거짓이 되므로 b==5는 판단하지 않는다. 불필요한 비교를 생략함으로써 속도를 높이는 이 기능을 쇼트 서키트라고 한다.



4-3. 블록 구조
[예제]
a=3
if a>4:
    print('a는 4보다 크다 1')
    print('블록 구조')


if a>4:
    print('a는 4보다 크다 2')
print('4보다 작다 - 블록이 아니라 무조건 실행')


>결과
4보다 작다 - 블록이 아니라 무조건 실행

맨 마지막 문장은 실행된다. 한꺼번에 실행되는 명령의 묶음을 블록이라 하며, 파이썬은 들여쓰기로 블록을 구분한다. 맨 마지막 문장은 조건과는 상관없는 별개의 문장이다.



[예제]
a=3
if a<4:
    print('a는 4보다 작다 1')
        print('블록 구조')


위처럼 들여쓰기를 더 해도 안되며, 공백이 하나라도 더 있으면 안된다. 이런 구조는 반복문, 함수에도 똑같이 적용된다.

파이썬은 별도의 블록기호 {} 를 사용하지 않고 들여쓰기로 소스형식을 강제한다. 탭 또는 공백을 사용하며, 공백의 개수는 제한이 없고 일정하면 된다. 탭은 편집기에 따라 폭이 달라지는 문제가 있어서 4개의 공백을 권장한다.



4-4.else문
if 조건:
    명령1
else:
    명령2

if문과 다르게 if-else문은 조건 진위에 따라 실행할 명령을 선택한다.


[예제]
a = 11

if a<10:
    print('10보다 작음')
else:
    print('10과 같거나 큼')


>결과
10과 같거나 큼



4-5.elif 문
if-else문을 확장하면, elif문이 중간에 들어가게 된다. 조건이 만족하지 않을시, elif문의 다른 조건을 더 점검한다.

if 조건1:
    명령1
elif 조건2:
    명령2
else:
    명령3

조건1을 만족하면 명령1을 실행하고 조건문이 끝난다. 조건1이 거짓이면 조건2를 평가하고, 참이면 명령2를 실행한다. 모두 거짓이면 명령3을 실행한다.




[예제]
a = 10

if a<10:
    print('10보다 작음')
elif a==10:
    print('10이다')
else:
    print('10보다 큼')


>결과
10이다

살펴봐야 할 조건이 많다면, elif는 얼마든지 더 올수 있다. 위 예제는 다음과 같다.



[예제]
a = 10

if a<10:
    print('10보다 작음')
else:
    if a==10:
        print('10이다')
    else:
        print('10보다 크다')


>결과
10이다

elif는 else if 의 약자이다. 풀어쓸수도 있지만, 비효율적이다.




4-6. if문 중첩
[예제]
a=1
b=2

if a==1:
    if b==2:
        print('[1] a=1이고 b=2입니다')
    else:
        print('no')

if a==1 and b==2:
    print('[2] a=1이고 b=2입니다')


>결과
[1] a=1이고 b=2입니다
[2] a=1이고 b=2입니다

if 문의 조건에 걸리는 명령의 종류에는 제한이 없다. print문으로 출력할수도 있고, 변수에 대입하거나 함수호출도 가능하다. if문도 하나의 명령이므로 if문 안에 들어갈수 있다.
똑같은 종류의 명령끼리 겹치는 현상을 중첩(nesting) 이라고 한다




5. 반복문
비슷한 명령을 반복해서 실행할때 사용한다

5-1. while
while 조건:
    명령

if문과 형식이 유사하지만, 조건이 만족하는 동안 계속 실행하게 된다. 명령 자리에는 명령 묶음인 블록이 오며 블록에 속하는 명령은 들여쓰기를 일치시켜야 된다.


[예제]
sum=0
num=1
while num<=100 :
    sum+=num
    num+=1
print("1~100까지 합은",sum)


>결과
1~100까지 합은 5050

반복적으로 처리되는 명령을 루프(loop)라고 하며, 여기서는 sum+=num, num+=1 이다. 루프는 특정 변수값을 기준으로 반복하는데, 반복을 통제하는 변수를 제어변수라고 한다. 이 예제에서는 num이 제어변수이다.

언젠가는 반복을 끝내야 하므로, 루프 안에는 조건의 진위 여부를 바꿀수 있는 명령이 포함되어야 한다. num+=1 명령이 없다면 조건은 계속 참이므로 루프가 끝나지 않게 된다.



[예제]
sum=0
num=1
count=0
while num<=100 :
    if num%3==0:
        count+=1
        sum+=num
    num+=1
print("1~100까지 3배수 개수는",count)
print("1~100까지 3배수 합은",sum)


>결과
1~100까지 3배수 개수는 33
1~100까지 3배수 합은 1683

코드의 구조를 잘 확립한다면, 범위를 바꾸는것은 어렵지 않다. 제어 변수의 증가값을 변경하거나, 조건문을 이용해서 합계를 구할수도 있다.



5-2. for 반복문
for문은 컬렉션의 요소를 순서대로 반복하면서 루프의 명령을 실행하는 반복문이다. 컬렉션은 여러개의 값을 모아 놓은 집합인데, 리스트나 문자열이 대표적이다.

for 제어변수 in 컬렉션 :
    명령



[예제]
for student in [1,2,3,4,5]:
    print(student, "입니다")
print('')
   
for student in [11,2,233,44,5]:
    print(student, "입니다2222")
print('')

for student in range(1,6):
    print(student, "입니다33333")
    #6 전까지함
print('')

for student in range(1,6,2):
    print(student, "입니다44")
    #2는 증감값이 된다


>결과
1 입니다
2 입니다
3 입니다
4 입니다
5 입니다

11 입니다2222
2 입니다2222
233 입니다2222
44 입니다2222
5 입니다2222

1 입니다33333
2 입니다33333
3 입니다33333
4 입니다33333
5 입니다33333

1 입니다44
3 입니다44
5 입니다44


결과는 while 문과 같지만, 제어변수를 초기화 시키거나, 증가시키는 문장이 없어서 더 짧고 간편하다.
리스트는 [] 괄호 안에 요소를 나열해 놓은 일종의 배열이며, for문은 요소를 하나씩 꺼내서 제어변수에 대입하고 루프에서 처리한다. 리스트에 불규칙한 값을 저장할수도 있고, 길이에 제한이 없어서 긴 배열도 처리할수 있다.

보통은 리스트를 만들고, 이 리스트 내의 요소를 반복한다
range(시작, 끝, 증가값)

시작값을 생략하면 0이 적용, 증가값을 생략하면 1이 적용된다. 끝값 자체는 표함되지 않는다.


[예제]
#1
sum=0
for num in range(1,101):
    sum=sum+num
print("1~100까지 총합 : ",sum)

#2
sum=0
count=0
for num in range(1,101):
    if num%3==0:
        count=count+1
        sum=sum+num
print("1~100까지 3배수 총합 : ",sum)
print("1~100까지 3배수 개수 : ",count)

#3
sum=0
count=0
for num in range(0,101,3):
    sum=sum+num
    count=count+1
print("1~100까지 3배수 총합 : ",sum)
print("1~100까지 3배수 개수 : ",count-1)
#0을 합할때 count가 올라가므로 -1 해준다


>결과
1~100까지 총합 :  5050
1~100까지 3배수 총합 :  1683
1~100까지 3배수 개수 :  33
1~100까지 3배수 총합 :  1683
1~100까지 3배수 개수 :  33

for문은 반복 범위가 명확한 경우, while문은 가변적인 경우에 주로 사용하면 된다.




5-3. 제어변수 활용
[예제]
print('a'*5)

for a in range(5):
    print("a")

for a in range(5):
    print("a", end='')


>결과
aaaaa
a
a
a
a
a
aaaaa



[예제]
for x in range(1,6):
    print('*'*x)

for x in range(1,6):
    for y in range(0,x+1):
        if(y==x):
            print()
        else:
            print('*',end='')

for x in range(1,6):
    for y in range(0,x+1):
        if(y!=x):
            print('*',end='')
    print()


for x in range(1,6):
    for y in range(1,x+1):
            print('*',end='')
    print()


>결과
*
**
***
****
*****



5-4. break
[예제]
score=[92,86,68,120,56]
for s in score:
    if(s<0 or s>100):
        break
    print(s)
print("성적 처리 끝")


>결과
92
86
68
성적 처리 끝

반복문 중간에 반복을 중지하거나 건너뛰어야 할 경우가 있는데, 이 경우 흐름 제어문을 사용한다.
break 명령은 반복문을 끝낸다. 무조건 탈출하는것이 아니라 특정한 조건에 의해 탈출하므로 if문과 함께 사용한다. (루프를 빠져나온다)




5-5.continue
[예제]
score=[92,86,68,120,56]
for s in score:
    if(s<0 or s>100):
        continue
    print(s)
print("성적 처리 끝")


>결과
92
86
68
56
성적 처리 끝


continue 명령은 이번 루프만 건너뛰고 나머지는 계속 수행하게 된다. 현재 반복만 중지하고 루프의 선두로 돌아가 조건을 점검하고 다음 반복을 계속 수행한다. break문과 마찬가지로 보통 if 문과 함께 사용한다.

break, continue 명령은 while문에도 똑같이 적용되며, 조건에따라 루프의 실행 여부를 통제한다.

